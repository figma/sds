import fs from "fs";
import { getFileStyles, getFileVariables } from "./fromFigma.mjs";

const JOIN_CHAR = "";
const CONVERT_TO_REM = true;
const NAMESPACE = "org.sds";
const TOKEN_PREFIX = "sds-";

const FILE_KEY = process.env.FIGMA_FILE_KEY;
const SKIP_REST_API = process.argv.includes("--skip-rest-api");
const WRITE_DIR = "../../src";

const COLOR_THEMES = ["sds_light"];
const COLOR_THEMES_DARK = ["sds_dark"];
// stripped from mode names above in theme class names
const COLOR_THEME_LIGHT_REMOVE = "_light";
const COLOR_THEME_DARK_REMOVE = "_dark";

initialize();

async function initialize() {
  if (!SKIP_REST_API) {
    const stylesJSON = await getFileStyles(FILE_KEY);
    fs.writeFileSync("./styles.json", JSON.stringify(stylesJSON, null, 2));
    const tokensJSON = await getFileVariables(FILE_KEY, NAMESPACE);
    fs.writeFileSync("./tokens.json", JSON.stringify(tokensJSON, null, 2));
  }
  const { processed, themeCSS } = processTokenJSON(
    JSON.parse(fs.readFileSync("./tokens.json")),
  );
  const variableLookups = [
    ...Object.values(processed.typography_primitives.main)[0],
    ...Object.values(processed.typography.main)[0],
    ...Object.values(processed.color_primitives.main)[0],
    ...Object.values(processed.color.main)[0],
    ...Object.values(processed.size.main)[0],
  ].reduce((into, item) => {
    into[item.figmaId] = item;
    return into;
  }, {});

  const stylesCSS = await processStyleJSON(
    JSON.parse(fs.readFileSync("./styles.json")),
    variableLookups,
  );

  fs.writeFileSync(
    `${WRITE_DIR}/theme.css`,
    [...themeCSS, ...stylesCSS].join("\n"),
  );
  console.log("Done!");
}

function processTokenJSON(data) {
  const processed = {
    color_primitives: {
      main: {},
    },
    color: {
      main: {},
      colorSchemes: COLOR_THEMES,
      colorSchemesDark: COLOR_THEMES_DARK,
    },
    size: { main: {} },
    typography_primitives: { main: {} },
    typography: { main: {} },
  };

  processCollection(data, processed.color_primitives, "@color_primitives", {
    prefix: "color",
  });
  processCollection(data, processed.color, "@color", {
    prefix: "color",
    replacements: {
      color_primitives: "color",
    },
  });
  processCollection(
    data,
    processed.typography_primitives,
    "@typography_primitives",
    {
      prefix: "typography",
      replacements: {
        "@responsive": "responsive",
        "Extra Bold Italic": "800 italic",
        "Semi Bold Italic": "600 italic",
        "Medium Italic": "500 italic",
        "Regular Italic": "400 italic",
        "Extra Light Italic": "200 italic",
        "Light Italic": "300 italic",
        "Black Italic": "900 italic",
        "Bold Italic": "700 italic",
        "Thin Italic": "100 italic",
      },
      convertPixelToRem: true,
    },
  );
  processCollection(data, processed.typography, "@typography", {
    prefix: "typography",
    replacements: {
      typography_primitives: "typography",
    },
    convertPixelToRem: true,
  });
  processCollection(data, processed.size, "@size", {
    prefix: "size",
    replacements: {
      "@responsive": "responsive",
    },
    convertPixelToRem: true,
  });

  const fileStringCSSLines = [
    "/*",
    " * This file is automatically generated by tokens.cjs!",
    " */",
  ];
  for (let key in processed) {
    fileStringCSSLines.push(
      ...fileStringCSSFromProcessedObject(processed[key], key),
    );
  }

  /* 
In the future, themeing will be handled via @container style() queries

:root {
  --theme: default; // blue, purple, teal
}

@container style(--theme: default) {
  :root {}
  @media (prefers-color-scheme: dark) {
    :root {}
  }
}
*/

  function fileStringCSSFromProcessedObject(
    {
      primitive,
      main,
      colorSchemes,
      colorSchemesDark,
      responsiveSizeOrder,
      responsiveSizeTokenSuffix,
    },
    key,
  ) {
    const lines = [];
    if (primitive) {
      const values = Object.values(primitive)[0];
      lines.push(
        ...[
          `/* ${key}: primitive */`,
          ":root {",
          drawCSSPropLines(values, "  "),
          "}",
        ],
      );
    }
    if (colorSchemes) {
      colorSchemes.forEach((scheme, i) => {
        if (i === 0) {
          lines.push(...[`/* ${key}: ${scheme} (default) */`, ":root {"]);
        } else {
          lines.push(
            ...[
              `/* ${key}: ${scheme} */`,
              `.${TOKEN_PREFIX}scheme-${key}-${scheme.replace(COLOR_THEME_LIGHT_REMOVE, "")} {`,
            ],
          );
        }
        lines.push(drawCSSPropLines(main[scheme], "  "), "}");
      });
      if (colorSchemesDark) {
        lines.push("@media (prefers-color-scheme: dark) {");
        colorSchemesDark.forEach((scheme, i) => {
          if (i === 0) {
            lines.push(...[`  /* ${key}: ${scheme} (default) */`, "  :root {"]);
          } else {
            lines.push(
              ...[
                `  /* ${key}: ${scheme} */`,
                `  .${TOKEN_PREFIX}scheme-${key}-${scheme.replace(COLOR_THEME_DARK_REMOVE, "")} {`,
              ],
            );
          }
          lines.push(drawCSSPropLines(main[scheme], "    "), "  }");
        });
        lines.push("}");
      }
    } else if (responsiveSizeOrder) {
      const regexp = new RegExp(`${responsiveSizeTokenSuffix}$`, "g");
      const sizes = responsiveSizeOrder.map((size) => {
        const found = main[size].find(({ property }) =>
          Boolean(property.match(regexp)),
        );
        return found ? found.value : "9999999px";
      });
      responsiveSizeOrder.forEach((size, i) => {
        if (i === 0) {
          lines.push(
            ...[
              `/* ${key}: ${size} (default) */`,
              ":root {",
              drawCSSPropLines(main[size], "  "),
              "}",
            ],
          );
        } else {
          lines.push(
            ...[
              `/* ${key}: ${size} */`,
              `@media (min-width: ${sizes[i]}) {`,
              "  :root {",
              drawCSSPropLines(main[size], "    "),
              "  }",
              "}",
            ],
          );
        }
      });
    } else {
      // main only
      if (main.length === 1) {
        const values = Object.values(main)[0];
        lines.push(...[":root {", drawCSSPropLines(values, "  "), "}"]);
      } else {
        let first;
        for (let k in main) {
          if (!first) {
            first = true;
            lines.push(...[`/* ${key}: ${k} (default) */`, ":root {"]);
          } else {
            lines.push(
              ...[`/* ${key}: ${k} */`, `.${TOKEN_PREFIX}theme-${key}-${k} {`],
            );
          }
          lines.push(...[drawCSSPropLines(main[k], "  "), "}"]);
        }
      }
    }
    return lines;
  }
  const codeSyntaxArrayString = `Promise.all([
    ${drawCodeSyntaxWeb(processed.size.main)},
    ${drawCodeSyntaxWeb(processed.typography_primitives.main)},
    ${drawCodeSyntaxWeb(processed.typography.main)},
    ${drawCodeSyntaxWeb(processed.color_primitives.main)},
    ${drawCodeSyntaxWeb(processed.color.main)}
    ].map(async ([variableId, webSyntax, description]) => {
      const variable = await figma.variables.getVariableByIdAsync(variableId);
      if (variable) {
        variable.setVariableCodeSyntax("WEB", webSyntax);
        variable.description = description;
      }
      return;
    })).then(() => console.log("DONE!")).catch(console.error)`;

  fs.writeFileSync("./tokensCodeSyntaxes.js", codeSyntaxArrayString);

  return { processed, themeCSS: fileStringCSSLines };

  function drawCSSPropLines(lines = [], indent = "  ") {
    return (
      lines
        .sort((a, b) => (a.property > b.property ? 1 : -1))
        .map((l) => `${indent}${l.property}: ${l.value}`)
        .join(";\n") + ";"
    );
  }

  function drawCodeSyntaxWeb(linesObject = { default: [] }) {
    const lines = linesObject[Object.keys(linesObject)[0]];
    return lines
      .sort((a, b) => (a.property > b.property ? 1 : -1))
      .map(
        (l) =>
          `["${l.figmaId}", "var(${l.property})", "${l.description || ""}"]`,
      )
      .join(",\n");
  }

  function processCollection(
    data,
    processed,
    mainKey,
    {
      replacements = {},
      convertPixelToRem = CONVERT_TO_REM,
      skipPrefix = "",
      prefix,
      removeFromLastKey = [],
    },
  ) {
    const fullPrefix = `${TOKEN_PREFIX}${prefix}`;
    traverse(
      processed.main,
      data[mainKey],
      replacements,
      mainKey,
      fullPrefix,
      convertPixelToRem,
      removeFromLastKey,
      "",
      fullPrefix ? [fullPrefix] : undefined,
      skipPrefix,
    );
  }

  function traverse(
    definitions,
    object,
    replacements,
    mainKey,
    prefix,
    convertPixelToRem = CONVERT_TO_REM,
    removeFromLastKey = [],
    currentType = "",
    keys = [],
    skipPrefix,
  ) {
    const lastKey = keys[keys.length - 1];
    if (lastKey) {
      removeFromLastKey.forEach((a) => {
        keys[keys.length - 1] = keys[keys.length - 1].replace(a, "");
      });
    }
    const property = `--${keys.join("-")}`;
    const propertyNameFull = keys
      .map((key) =>
        key
          .split(/[^\dA-Za-z]/)
          .map((k) => `${k.charAt(0).toUpperCase()}${k.slice(1)}`)
          .join(""),
      )
      .join("");
    // .replace(/^color/i, "");
    const valueWithReplacements = (value) => {
      if (typeof value !== "string") return value;
      for (let replacement in replacements) {
        value = value.replace(replacement, replacements[replacement]);
      }
      return value.toLowerCase();
    };
    const propertyName =
      propertyNameFull.charAt(0).toLowerCase() + propertyNameFull.slice(1);
    const type = object.$type || currentType;
    if (skipPrefix && propertyName.match(skipPrefix)) return;
    if ("$value" in object) {
      if ("$extensions" in object && NAMESPACE in object.$extensions) {
        const description = object.$description || "";
        const figmaId = object.$extensions[NAMESPACE].figmaId;
        for (let mode in object.$extensions[NAMESPACE].modes) {
          definitions[mode] = definitions[mode] || [];
          definitions[mode].push({
            property,
            propertyName,
            figmaId,
            description,
            value: valueWithReplacements(
              valueToCSS(
                property,
                object.$extensions[NAMESPACE].modes[mode],
                mainKey,
                convertPixelToRem,
                prefix,
              ),
            ),
            type,
          });
        }
      } else {
        const description = object.$description || "";
        const figmaId =
          "$extensions" in object && NAMESPACE in object.$extensions
            ? object.$extensions[NAMESPACE].figmaId
            : "UNDEFINED";
        const mode = "default";
        definitions[mode] = definitions[mode] || [];
        definitions[mode].push({
          property,
          propertyName,
          description,
          figmaId,
          value: valueWithReplacements(
            valueToCSS(property, object.$value, mainKey, convertPixelToRem, ""),
          ),
          type,
        });
      }
    } else {
      Object.entries(object).forEach(([key, value]) => {
        if (key.charAt(0) !== "$") {
          traverse(
            definitions,
            value,
            replacements,
            mainKey,
            prefix,
            convertPixelToRem,
            removeFromLastKey,
            type,
            [...keys, key],
            skipPrefix,
          );
        }
      });
    }
  }

  function valueToCSS(
    property,
    value,
    mainKey,
    convertPixelToRem,
    prefix = "",
  ) {
    if (value.toString().charAt(0) === "{")
      return `var(--${value
        .replace(`${mainKey}${JOIN_CHAR}`, prefix)
        .replace(/[\. ]/g, "-")
        .replace(/^\{/, "")
        .replace(/\}$/, "")})`;
    const valueIsDigits = value.toString().match(/^-?\d+(\.\d+)?$/);
    const isRatio = property.match(/(ratio-)/);
    const isNumeric =
      valueIsDigits && !property.match(/(weight|ratio-)/) && !isRatio;
    if (isNumeric) {
      return convertPixelToRem ? `${parseInt(value) / 16}rem` : `${value}px`;
    } else if (isRatio) {
      return Math.round(value * 10000) / 10000;
    }
    if (property.match("family-mono")) {
      return `"${value}", monospace`;
    } else if (property.match("family-sans")) {
      return `"${value}", sans-serif`;
    } else if (property.match("family-serif")) {
      return `"${value}", serif`;
    }
    return value;
  }
}

async function processStyleJSON(data, variablesLookup) {
  const effectDefs = [];
  const text = [];
  data.forEach(({ type, ...style }) => {
    if (type === "TEXT") {
      const {
        name,
        fontSize,
        fontFamily,
        fontWeight,
        fontStyle = "normal",
      } = style;

      const css = [
        valueFromPossibleVariable(fontStyle),
        valueFromPossibleVariable(fontWeight),
        valueFromPossibleVariable(fontSize),
        valueFromPossibleVariable(fontFamily),
      ].join(" ");
      text.push(
        `--${TOKEN_PREFIX}font-${name
          .replace(/^[^a-zA-Z0-9]+/, "")
          .replace(/[^a-zA-Z0-9]+/g, "-")
          .toLowerCase()}: ${css};`,
      );
    } else if (type === "EFFECT") {
      const { name, effects } = style;
      const safeName = sanitizeName(name);
      const shadows = [];
      const filters = [];
      const backdropFilters = [];
      effects.forEach((effect) => {
        if (effect.visible) {
          if (effect.type.match("SHADOW")) {
            shadows.push(formatEffect(effect));
          }
          if (effect.type.match("LAYER_BLUR")) {
            filters.push(formatEffect(effect));
          }
          if (effect.type.match("BACKGROUND_BLUR")) {
            backdropFilters.push(formatEffect(effect));
          }
        }
      });
      if (shadows.length) {
        effectDefs.push(
          `--${TOKEN_PREFIX}effects-shadows-${safeName}: ${shadows.join(", ")};`,
        );
      }
      if (filters.length) {
        effectDefs.push(
          `--${TOKEN_PREFIX}effects-filter-${safeName}: ${filters[0]};`,
        );
      }
      if (backdropFilters.length) {
        effectDefs.push(
          `--${TOKEN_PREFIX}effects-backdrop-filter-${safeName}: ${backdropFilters[0]};`,
        );
      }
    }
  });

  return [
    "/* styles */",
    ":root {",
    "  " + [...text, ...effectDefs].join("\n  "),
    "}",
  ];

  function valueFromPossibleVariable(item = "") {
    if (typeof item === "object") {
      // attempting to find bound variables
      const variable = variablesLookup[item.id];
      return variable ? `var(${variable.property})` : JSON.stringify(item);
    } else if (item.match(/^[1-9]00$/)) {
      // attempting to find variable for weights
      // the scenario where style is used so weight is int
      const variable = variablesLookup.find(({ value }) => value === item);
      return variable ? `var(${variable.property})` : item;
    }
    return item;
  }

  function sanitizeName(name) {
    return name
      .replace(/[^a-zA-Z0-9 ]/g, " ")
      .replace(/^ +/, "")
      .replace(/ +$/, "")
      .replace(/ +/g, "-")
      .toLowerCase();
  }

  function formatEffect({ type, ...effect }) {
    if (type === "DROP_SHADOW" || type === "INNER_SHADOW") {
      const {
        radius,
        offset: { x, y },
        spread,
        hex,
        boundVariables,
      } = effect;
      const numbers = [
        boundVariables.offsetX
          ? valueFromPossibleVariable(boundVariables.offsetX)
          : `${x}px`,
        boundVariables.offsetY
          ? valueFromPossibleVariable(boundVariables.offsetY)
          : `${y}px`,
        boundVariables.radius
          ? valueFromPossibleVariable(boundVariables.radius)
          : `${radius}px`,
        boundVariables.spread
          ? valueFromPossibleVariable(boundVariables.spread)
          : `${spread}px`,
        boundVariables.color
          ? valueFromPossibleVariable(boundVariables.color)
          : `${hex}px`,
      ];
      return `${type === "INNER_SHADOW" ? "inset " : ""}${numbers.join(" ")}`;
    } else if (type === "LAYER_BLUR" || type === "BACKGROUND_BLUR") {
      const { radius, boundVariables } = effect;
      return `blur(${boundVariables.radius ? valueFromPossibleVariable(boundVariables.radius) : `${radius}px`})`;
    }
  }
}
